Csmith的前世今生

零八年金融危机正酣的时候，某一天我正盯着股市心惊肉跳，老板（博导的俗称）John和小老板Eric把我叫到办公室，对望了一眼，说，“我们打算让你做randprog。”

randprog是他们俩合作的一个随机程序生成器。程序先产生一个随机数种子，然后通过一系列的随机决定树，把整个程序构建起来。最后以C语句输出，就是一个合法的的C程序。可以通过gcc编译，编译后还可以执行。除了看起来有些机械呆板，randprog产生的程序和码工们吭哧吭哧码出来的程序没有很大区别。当然还有一点，randprog产生的程序毫无目的性，只知道一味的加减乘除，所有看起来有点傻。

傻归傻，randprog可是取得了意想不到的成功。当时各大编译器对C语言的volatile这一关键词的支持比较懈怠。按照C语言标准，引入volatile的本意是为了支持多线程共享变量。如果某个变量被定义成volatile，编译器必须保证单个线程对其读写访问不能被优化。譬如说，线程A连续读了一个变量两次。一般编译器把第二次读优化掉，因为第一次读的值可能还在寄存器或者缓存呢，没必要再访问慢吞吞的内存一次。但如果变量是volatile就不能投机取巧了，因为在两次读之间，可能有另外一个线程改写了volatile变量值。

John和Eric拿着randprog去测各大编译器对volatile的支持时，又用了一个奇淫技巧叫差异性测试。因为randprog产生一个程序太容易，可能一秒钟能生成数百个C程序。如果我们正儿八经地把每个程序编译成汇编码，然后用放大镜看对应volatile的汇编码是否正确，那我们一辈子就耗进去了。但换一个角度，如果把同一个randprog产生的程序同时丢给两个编译器，然后跑一下它们输出的可执行文件，结果不同的话，不就间接证明了它们俩之间有一个输出了错误的汇编码吗？这不就是一个编译器的bug吗？

randprog的意义在于把随机产生和差异性测试结合起来，成为随机差异性测试（random differential testing）。如果只有一个随机程序，用差异性测试去找bug就跟海底捞针一样。但如果我们以量取胜，用大量的随机程序去做差异性测试，胜算就大大增加了，就跟拿渔网去大海捞鱼（bug）差不多。这时候，随机产生器的好坏就体现出来了。越好的随机产生器，织出来渔网的网眼就越小，捞到的鱼（bug）就更多。而坏的随机产生器，如果网眼太大，可能一条鱼都捞不到！

话说John和Eric这哥俩拿着randprog这副网，捞了不少跟volatile相关的鱼（bug）。但海里鱼毕竟有限，randprog能找到的bug越来越少。为了升级渔网，他们找到了我。这就是Csmith的起源。虽然Csmith这个名字是两年后才诞生的。

我接手后，先加了struct，这样Csmith就不至于只跟整型打交道了。Csmith可以用struct作为函数的输入参数或者返回值，也可以随机产生struct的初始值，还可以抓struct里面的整数字段做加减乘除。最让编译器头疼的大概是嵌套struct。Csmith产生的struct可能包含另一个struct，一次次嵌入可能多达十几层（后来我们做了限制）。这可能是编译器做梦都想不到的。

下一步我开始尝试产生指针。指针是C语言的一大特色，也是最让人头疼的地方，因为C允许指针的指针，指针的指针的指针。。。无限循环，往往就把人绕进去了。当年我还不知道为了一个指针分析前辈大牛们已经发了无数论文。懵懵懂懂的开发了一个新的指针分析，估计到现在还是独一份。即不是静态也不是动态，效率也还可以。一开始指针分析的虫子很多，Csmith产生的程序动不动就因为无效指针而崩溃。其中对循环语句的指针分析最容易出错，除虫杀了我不少脑细胞。John建议我在每个语句做完分析之后产生一个assertion，这样分析结果有错的话可以马上检测到。到今天，Csmith的命令行还有一个“偏执狂”选项，就是由此而来。这个偏执狂选项确实对除虫大有帮助。慢慢地随着虫子一个个被杀死，Csmith的指针分析准确性基本达到百分之百，产生的指针语句不再会崩溃。这个paranoid选项也基本没有人用了。

之后我最想做的一件事，就是让Csmith产生的程序看起来没那么傻。人类写的程序都是浑然一体的：定义几个变量，对它们进行一系列的读写操作，然后输出一个或几个变量结果。Csmith则不然，经常一顿操作猛如虎，最后一看，那些被读写的变量对最后结果都毫无影响。在Csmith产生程序时，我试图引入一些上下文，告诉它哪些变量值得读写，哪些不值得。但很遗憾，这部分工作到我毕业都没完成。唯一可以安慰自己的是在我们之前的随机程序产生器都是无头苍蝇式的，Csmith已经算比较聪明比较有目的性了。

2009年时，很明显我们已经人手不够了。老板把另一个得力的学生也投入Csmith的工作。Union，随机深度限制，和其它静态分析工具的整合，数组，跳转，和逗号，都是我们这个小小团队在不到一年时间里加到Csmith里面的。我印象比较深的是跳转语句，对指针分析带来极大的挑战，后来我们不得不对其做了一些限制以保证指针分析继续有效。

2010上半年我们沉浸在“甜蜜的烦恼“中，因为Csmith找到的编译器bug太多了。换句话说，就是Csmith编的渔网太密了。John总是下班前下载最新版的Csmith，然后用随机差异性测试脚本跑一整夜，第二天上班就发现有不少鱼儿（bug）上钩。问题是我们还不能原样把Csmith的产生的随机程序提交给GCC或LLVM的维护者。一个随机程序里往往只有一小段是为bug复现所必须的.（负责任的）我们的大量心血就花在找到那一小段代码上。这份单调耗时的工作直到两年后才被我们开发的另一个工具CReduce代替。对负责除虫的码工而言，一个短小精悍又能复现bug的测试用例简直就是天上的福音。当时GCC和LLVM的维护者对我们团队提交的bug报告如此青睐，以至于他们分别邀请John和我在各自的会议上做了学术报告。

2010年下半年我们开始写论文。John的目标一开始就是PLDI。当时我们已经发现了四五百个编译器的bug。开始是想分成两篇论文的，一篇介绍我们是如何找到这么多bug，另一篇介绍这些bug本身，它们是如何混入编译器的，我们的发现对编译器的整体质量提高，等等。但后来经过内部讨论，觉得这两部分关系太紧密了，还是一起发出来好。因为内容太多，当时PLDI一篇论文的上限是十一页，所以我们绞尽脑汁，把可有可无的部分去掉。最后完稿的论文里只字未提指针分析，其实我个人觉得光那部分就可以发一篇论文。还有对bug的分析我们也只精挑细选了八个。写论文过程中，老板起了一锤定音的决定性作用。他对我们研究领域的前沿状态最清楚，知道什么样的信息值得写，什么不值得。我和师弟（也是中国人）经常用一大段话才能表达的意思，他用点睛之笔一两句话就能概括。总而言之，尽管有一些权衡取舍，我对我们最后呈现在世人面前的这篇论文《Finding and understanding bugs in C compilers》深感自豪。

老板把稿件发给一些业界大牛审核，收获了不少赞扬。其中一位审核者问了个问题：”你们觉得之所以能发现这么多别人没找到的bug，是因为你们更聪明呢（用了别人没想到的方法），还是更勤奋呢？（用了别人的方法但做得更好）“。这么多年，我一直思考这个问题。我觉得答案是两者皆有，但更偏向于后者。随机差异性测试的思维方式已经存在很多年，但此前没有人跟我们一样把它用到极致，也没有人像我们一样如此努力开发一个有智慧有灵魂的随机产生器。这也许是Csmith成功的唯一秘诀。

我最大的遗憾，是没有考虑Csmith的可扩展性和可维护性。当Utah团队随着我和师弟的毕业而解散，Csmith的短板就暴露出来了。很多代码没有注释，很多设计没有解释前因后果。这可以解释在开源在github上的Csmith为什么没有新的代码贡献者。也可以解释为什么十年了，Csmith还被业界大公司使用，没有一款新的编译器随机测试工具能超越它。最近几年，我试图重新拾起Csmith的维护工作，但往往被繁忙的日常工作所阻扰。

我们一直收到用户呼吁，把Csmith用到C语言之外的其它编译器或解释器的测试。每次我们都说，很遗憾，Csmith是为C语言设计的，很难产生其它语言的随机程序。确实，就指针分析看，只有C语言有指针的指针，其它语言最多只有object的指针。Csmith里面的指针分析需要大幅度简化才能适用其它语言。此外C之外的程序语言往往自带丰富的language library。Csmith需要对这些language library相当熟悉，才能产生代码调用它们。我一直有一个梦想把Csmith扩展为支持任意程序语言的ProgSmith。有兴趣合作的读者可以私聊。

